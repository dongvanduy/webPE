@{
    ViewData["Title"] = "PCB AI Inspector";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<style>
    /* Giao diện Toolbar */
    .toolbar-container {
        background: #f0f2f5;
        padding: 10px;
        border-bottom: 1px solid #ccc;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        position: sticky;
        top: 0;
        z-index: 100;
    }

    /* Khung chứa Canvas */
    .canvas-wrapper {
        position: relative;
        width: 100%;
        height: 80vh; /* Chiều cao 80% màn hình */
        overflow: hidden;
        background: #333; /* Màu nền tối để dễ nhìn board */
        border: 1px solid #000;
    }

    /* Màn hình loading */
    #loadingOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 9999;
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    .loader {
        border: 8px solid #f3f3f3;
        border-top: 8px solid #3498db;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
    }

    @@keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    /* Nút bấm */
    .btn-tool {
        margin-right: 5px;
    }

        .btn-tool.active {
            border: 2px solid #0056b3;
            background-color: #e2e6ea;
        }
</style>

<div class="row">
    <div class="col-12">
        <div class="toolbar-container d-flex flex-wrap align-items-center">
            <input type="file" id="inpFile" class="form-control w-auto me-3" accept=".jpg,.jpeg,.png,.pdf" />

            <button class="btn btn-primary btn-tool" onclick="runAI()">
                <i class="fa fa-bolt"></i> Quét AI (Scan)
            </button>

            <div class="vr mx-2"></div>

            <button class="btn btn-light btn-tool" id="btnPan" onclick="setMode('pan')">
                <i class="fa fa-hand-paper-o"></i> Di chuyển (Pan)
            </button>

            <button class="btn btn-light btn-tool" id="btnZone" onclick="setMode('draw')">
                <i class="fa fa-pencil-square-o"></i> Vẽ Zone
            </button>

            <div class="vr mx-2"></div>

            <button class="btn btn-success btn-tool" onclick="alert('Chức năng đang phát triển')">
                <i class="fa fa-file-powerpoint-o"></i> Xuất Báo Cáo
            </button>

            <span class="ms-auto fw-bold" id="statusText">Ready</span>
        </div>
    </div>
</div>

<div class="row mt-2">
    <div class="col-12">
        <div class="canvas-wrapper" id="canvasWrapper">
            <canvas id="c"></canvas>
        </div>
    </div>
</div>

<div id="loadingOverlay" style="display:none;">
    <div class="loader"></div>
    <h4 id="loadingText">Đang xử lý...</h4>
</div>

<script src="~/lib/jquery/dist/jquery.min.js"></script>
<script src="~/lib/fabric.min.js"></script>

<script type="module">
    // Import PDF.js module - sẽ tự động set globalThis.pdfjsLib
    await import('/lib/pdfjs/build/pdf.mjs');
    
    // Cấu hình Worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = '/lib/pdfjs/build/pdf.worker.mjs';
    console.log("PDF.js loaded successfully");
    
    // Thông báo đã sẵn sàng
    window.pdfjsReady = true;
    window.dispatchEvent(new Event('pdfjsReady'));
</script>
<script>
    // --- CẤU HÌNH PDF.js ---
    // Sử dụng Promise để đợi pdfjsLib được load từ module
    let pdfjsLibReady = new Promise((resolve) => {
        if (window.pdfjsReady) {
            resolve();
        } else {
            window.addEventListener('pdfjsReady', () => resolve());
        }
    });

    let canvas;
    let currentMode = 'pan'; // 'pan' hoặc 'draw'
    let isDragging = false;
    let lastPosX, lastPosY;
    let imgElement = null; // Giữ ảnh gốc sau khi load

    // 1. KHỞI TẠO CANVAS
    $(document).ready(function () {
        initCanvas();
        window.addEventListener('resize', resizeCanvas);
        $('#btnPan').addClass('active'); // Mặc định là chế độ Pan
    });

    function initCanvas() {
        const wrapper = document.getElementById('canvasWrapper');
        canvas = new fabric.Canvas('c', {
            width: wrapper.clientWidth,
            height: wrapper.clientHeight,
            fireRightClick: true,  // Cho phép chuột phải
            stopContextMenu: true, // Chặn menu chuột phải mặc định của trình duyệt
            selection: false       // Tắt selection box mặc định của fabric
        });

        // Sự kiện chuột
        canvas.on('mouse:wheel', onZoom);
        canvas.on('mouse:down', onMouseDown);
        canvas.on('mouse:move', onMouseMove);
        canvas.on('mouse:up', onMouseUp);
    }

    function resizeCanvas() {
        const wrapper = document.getElementById('canvasWrapper');
        canvas.setWidth(wrapper.clientWidth);
        canvas.setHeight(wrapper.clientHeight);
    }

    // 2. XỬ LÝ UPLOAD FILE (ẢNH HOẶC PDF)
    document.getElementById('inpFile').onchange = async function(e) {
        const file = e.target.files[0];
        if (!file) return;

        showLoading(true, "Đang đọc file...");
        canvas.clear(); // Xóa canvas cũ

        try {
            if (file.type === 'application/pdf') {
                await renderPdfToCanvas(file);
            } else {
                // Đọc như ảnh thường
                const reader = new FileReader();
                reader.onload = function(f) {
                    loadImageToFabric(f.target.result);
                };
                reader.readAsDataURL(file);
            }
        } catch (err) {
            console.error(err);
            alert("Lỗi đọc file: " + err.message);
            showLoading(false);
        }
    };

    // Hàm render PDF -> Ảnh (Dùng PDF.js)
    async function renderPdfToCanvas(file) {
        // Đợi pdfjsLib sẵn sàng
        await pdfjsLibReady;
        
        const fileData = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(fileData).promise;

        // Lấy trang 1
        const page = await pdf.getPage(1);

        // Tạo canvas ảo để vẽ PDF lên
        const viewport = page.getViewport({ scale: 2.0 }); // Scale 2.0 để ảnh nét hơn
        const tempCanvas = document.createElement('canvas');
        const context = tempCanvas.getContext('2d');
        tempCanvas.height = viewport.height;
        tempCanvas.width = viewport.width;

        await page.render({
            canvasContext: context,
            viewport: viewport
        }).promise;

        // Chuyển canvas ảo thành DataURL (base64 image)
        const imgData = tempCanvas.toDataURL('image/png');
        loadImageToFabric(imgData);
    }

    // Hàm vẽ ảnh nền lên Fabric
    function loadImageToFabric(dataUrl) {
        fabric.Image.fromURL(dataUrl, function(img) {
            imgElement = img;

            // Tính toán scale để ảnh vừa khít màn hình lúc đầu
            const wrapper = document.getElementById('canvasWrapper');
            const scale = Math.min(
                wrapper.clientWidth / img.width,
                wrapper.clientHeight / img.height
            );

            // Set ảnh nền
            canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), {
                scaleX: scale,
                scaleY: scale,
                originX: 'left',
                originY: 'top'
            });

            // Reset viewport
            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
            showLoading(false);
            updateStatus("Đã tải ảnh. Sẵn sàng quét AI.");
        });
    }

    // 3. GỌI AI BACKEND
    function runAI() {
        const fileInput = document.getElementById('inpFile');
        if(fileInput.files.length === 0) {
            alert("Vui lòng chọn file trước!");
            return;
        }

        showLoading(true, "AI đang phân tích bo mạch...");

        const formData = new FormData();
        formData.append("file", fileInput.files[0]);

        $.ajax({
            url: '/AOI/CheckDraw/ScanBoard', // Gọi Controller ASP.NET
            type: 'POST',
            data: formData,
            processData: false,
            contentType: false,
            success: function(res) {
                // res là JSON trả về từ Python
                // { components: [ {box: [x1,y1,x2,y2], designator: "R1"} ] }

                if (res.status && res.status === 'error') {
                    alert(res.message);
                } else if (res.components) {
                    drawComponents(res.components);
                    updateStatus(`Tìm thấy ${res.components.length} linh kiện.`);
                } else {
                    console.log(res);
                    alert("Phản hồi không đúng định dạng JSON");
                }
            },
            error: function(xhr, status, error) {
                alert("Lỗi kết nối: " + error);
                console.error(xhr.responseText);
            },
            complete: function() {
                showLoading(false);
            }
        });
    }

    function drawComponents(components) {
        // Lấy thông số scale hiện tại của ảnh nền để vẽ box đúng vị trí tương đối
        if (!canvas.backgroundImage) return;

        const bgScaleX = canvas.backgroundImage.scaleX;
        const bgScaleY = canvas.backgroundImage.scaleY;

        // Xóa các box cũ nếu có
        const objects = canvas.getObjects();
        objects.forEach(obj => {
            if (obj.data && obj.data.type === 'component') {
                canvas.remove(obj);
            }
        });

        components.forEach(c => {
            // Box từ AI trả về là toạ độ trên ảnh gốc (Pixel)
            const [x1, y1, x2, y2] = c.box;

            const w = x2 - x1;
            const h = y2 - y1;

            const rect = new fabric.Rect({
                left: x1 * bgScaleX, // Nhân với scale của ảnh nền
                top: y1 * bgScaleY,
                width: w * bgScaleX,
                height: h * bgScaleY,
                fill: 'transparent',
                stroke: '#00ff00', // Màu xanh lá
                strokeWidth: 2,
                selectable: true,  // Cho phép click chọn
                hasRotatingPoint: false
            });

            // Lưu dữ liệu vào object để dùng sau (ví dụ: hiển thị tên)
            rect.data = { type: 'component', designator: c.designator };

            canvas.add(rect);
        });

        canvas.requestRenderAll();
    }

    // 4. CÁC HÀM TIỆN ÍCH (ZOOM, PAN, MODE)
    function onZoom(opt) {
        var delta = opt.e.deltaY;
        var zoom = canvas.getZoom();
        zoom *= 0.999 ** delta;
        if (zoom > 20) zoom = 20;
        if (zoom < 0.01) zoom = 0.01;
        canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
        opt.e.preventDefault();
        opt.e.stopPropagation();
    }

    function onMouseDown(opt) {
        var evt = opt.e;
        if (currentMode === 'pan') {
            isDragging = true;
            lastPosX = evt.clientX;
            lastPosY = evt.clientY;
            canvas.setCursor('grab');
        }
    }

    function onMouseMove(opt) {
        if (isDragging && currentMode === 'pan') {
            var e = opt.e;
            var vpt = canvas.viewportTransform;
            vpt[4] += e.clientX - lastPosX;
            vpt[5] += e.clientY - lastPosY;
            canvas.requestRenderAll();
            lastPosX = e.clientX;
            lastPosY = e.clientY;
        }
    }

    function onMouseUp(opt) {
        if (currentMode === 'pan') {
            isDragging = false;
            canvas.setCursor('default');
        }
    }

    function setMode(mode) {
        currentMode = mode;
        // Update UI Button style
        $('.btn-tool').removeClass('active');
        if (mode === 'pan') {
            $('#btnPan').addClass('active');
            canvas.selection = false; // Tắt selection box
            canvas.forEachObject(o => o.selectable = false); // Không cho chọn box khi đang pan
        } else if (mode === 'draw') {
            $('#btnZone').addClass('active');
            canvas.selection = true;
            canvas.forEachObject(o => o.selectable = true);
        }
    }

    function showLoading(show, text) {
        const overlay = document.getElementById('loadingOverlay');
        const txt = document.getElementById('loadingText');
        if (show) {
            overlay.style.display = 'flex';
            if (text) txt.innerText = text;
        } else {
            overlay.style.display = 'none';
        }
    }

    function updateStatus(msg) {
        document.getElementById('statusText').innerText = msg;
    }
</script>